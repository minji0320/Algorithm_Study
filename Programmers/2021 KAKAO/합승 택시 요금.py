def solution(n, s, a, b, fares):
    # 초기 그래프 생성
    map = [[9999999999 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        map[i][i] = 0
    for c, d, f in fares:
        map[c - 1][d - 1] = f
        map[d - 1][c - 1] = f

    # 플로이드 알고리즘 활용하여 최단 거리 구하기
    for k in range(n):
        for i in range(n):
            for j in range(n):
                map[i][j] = min(map[i][j], map[i][k] + map[k][j])

    return min(map[s - 1][k] + map[k][a - 1] + map[k][b - 1] for k in range(n))

# 정확성  테스트
# 테스트 1 〉	통과 (0.08ms, 10.3MB)
# 테스트 2 〉	통과 (0.13ms, 10.2MB)
# 테스트 3 〉	통과 (0.08ms, 10.2MB)
# 테스트 4 〉	통과 (0.30ms, 10.2MB)
# 테스트 5 〉	통과 (0.54ms, 10.2MB)
# 테스트 6 〉	통과 (1.32ms, 10.2MB)
# 테스트 7 〉	통과 (0.52ms, 10.3MB)
# 테스트 8 〉	통과 (1.84ms, 10.3MB)
# 테스트 9 〉	통과 (1.72ms, 10.3MB)
# 테스트 10 〉	통과 (2.54ms, 10.4MB)
# 효율성  테스트
# 테스트 1 〉	통과 (294.41ms, 10.5MB)
# 테스트 2 〉	통과 (959.93ms, 11.1MB)
# 테스트 3 〉	통과 (2100.75ms, 11.4MB)
# 테스트 4 〉	통과 (2290.63ms, 11.5MB)
# 테스트 5 〉	통과 (2306.43ms, 11.4MB)
# 테스트 6 〉	통과 (2074.25ms, 11.5MB)
# 테스트 7 〉	통과 (2355.38ms, 13.9MB)
# 테스트 8 〉	통과 (2345.25ms, 14MB)
# 테스트 9 〉	통과 (2423.08ms, 12.9MB)
# 테스트 10 〉	통과 (2536.01ms, 12.9MB)
# 테스트 11 〉	통과 (2399.15ms, 12.9MB)
# 테스트 12 〉	통과 (2102.18ms, 12.8MB)
# 테스트 13 〉	통과 (2318.76ms, 12.8MB)
# 테스트 14 〉	통과 (2288.45ms, 12.8MB)
# 테스트 15 〉	통과 (2143.61ms, 12.8MB)
# 테스트 16 〉	통과 (2370.00ms, 11.5MB)
# 테스트 17 〉	통과 (2348.99ms, 11.4MB)
# 테스트 18 〉	통과 (2360.72ms, 11.2MB)
# 테스트 19 〉	통과 (2333.59ms, 11.5MB)
# 테스트 20 〉	통과 (2050.38ms, 11.7MB)
# 테스트 21 〉	통과 (2308.31ms, 11.7MB)
# 테스트 22 〉	통과 (2287.68ms, 12.9MB)
# 테스트 23 〉	통과 (2285.92ms, 12.7MB)
# 테스트 24 〉	통과 (2122.20ms, 12.7MB)
# 테스트 25 〉	통과 (2297.62ms, 11.2MB)
# 테스트 26 〉	통과 (2063.05ms, 11MB)
# 테스트 27 〉	통과 (2249.18ms, 10.5MB)
# 테스트 28 〉	통과 (2210.17ms, 10.4MB)
# 테스트 29 〉	통과 (287.19ms, 10.4MB)
# 테스트 30 〉	통과 (292.83ms, 10.3MB)

def solution(n, s, a, b, fares):
    # 초기 그래프 생성
    graph = [[9999999999 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        graph[i][i] = 0
    for c, d, f in fares:
        graph[c - 1][d - 1] = f
        graph[d - 1][c - 1] = f

    # 최단 거리 구하기
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if graph[i][j] > graph[i][k] + graph[k][j]:
                    graph[i][j] = graph[i][k] + graph[k][j]

    return min(graph[s - 1][k] + graph[k][a - 1] + graph[k][b - 1] for k in range(n))

# 정확성  테스트 > min 함수 대신 if 문 사용 시 시간 감소됨
# 테스트 1 〉	통과 (0.05ms, 10.3MB)
# 테스트 2 〉	통과 (0.08ms, 10.4MB)
# 테스트 3 〉	통과 (0.09ms, 10.3MB)
# 테스트 4 〉	통과 (0.19ms, 10.3MB)
# 테스트 5 〉	통과 (0.30ms, 10.3MB)
# 테스트 6 〉	통과 (0.45ms, 10.4MB)
# 테스트 7 〉	통과 (0.55ms, 10.3MB)
# 테스트 8 〉	통과 (0.73ms, 10.3MB)
# 테스트 9 〉	통과 (1.27ms, 10.3MB)
# 테스트 10 〉	통과 (1.38ms, 10.3MB)
# 효율성  테스트
# 테스트 1 〉	통과 (149.34ms, 10.6MB)
# 테스트 2 〉	통과 (497.71ms, 11.2MB)
# 테스트 3 〉	통과 (1072.57ms, 11.5MB)
# 테스트 4 〉	통과 (1190.40ms, 11.5MB)
# 테스트 5 〉	통과 (1069.98ms, 11.5MB)
# 테스트 6 〉	통과 (1189.41ms, 11.5MB)
# 테스트 7 〉	통과 (1181.14ms, 13.9MB)
# 테스트 8 〉	통과 (1084.72ms, 14.2MB)
# 테스트 9 〉	통과 (1239.54ms, 13MB)
# 테스트 10 〉	통과 (1120.38ms, 13.1MB)
# 테스트 11 〉	통과 (1218.89ms, 13MB)
# 테스트 12 〉	통과 (1076.51ms, 12.9MB)
# 테스트 13 〉	통과 (1188.23ms, 12.9MB)
# 테스트 14 〉	통과 (1192.92ms, 12.9MB)
# 테스트 15 〉	통과 (1082.31ms, 12.8MB)
# 테스트 16 〉	통과 (1075.41ms, 11.5MB)
# 테스트 17 〉	통과 (1190.14ms, 11.5MB)
# 테스트 18 〉	통과 (1198.16ms, 11.3MB)
# 테스트 19 〉	통과 (1186.95ms, 11.6MB)
# 테스트 20 〉	통과 (1172.47ms, 11.8MB)
# 테스트 21 〉	통과 (1066.96ms, 11.8MB)
# 테스트 22 〉	통과 (1087.71ms, 12.8MB)
# 테스트 23 〉	통과 (1189.66ms, 12.9MB)
# 테스트 24 〉	통과 (1201.04ms, 12.9MB)
# 테스트 25 〉	통과 (1195.94ms, 11.3MB)
# 테스트 26 〉	통과 (1194.01ms, 11MB)
# 테스트 27 〉	통과 (1076.03ms, 10.6MB)
# 테스트 28 〉	통과 (1105.85ms, 10.5MB)
# 테스트 29 〉	통과 (134.31ms, 10.4MB)
# 테스트 30 〉	통과 (135.94ms, 10.4MB)